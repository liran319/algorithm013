# 学习笔记 —— 第七周

## 位运算

### 常用操作
* 左移： `0011 >> 1 == 0001`: 右移一位，除以2
* 右移： `0011 << 1 == 0110`: 座移一位，乘以2
* 按位与： `0100 & 0010 == 0000`
* 按位或： `0100 | 0010 == 0110`
* 按位取反（非）：`~0100 == 1011`
* 按位异或：`1100 ^ 0010 == 1110` 同一位，相同为0，不同为1

### 异或的一些操作
* `x ^ 0 == x`
* `x ^ 1s == ~x` **注：1s是全1**
* `x ^ (~x) == 1s`
* `x ^ x == 0`

### 指定位置的位运算

1. 将x的最右边n位清零：`x & (~0 << n)`
2. 获取x的第n位值：`(x >> n) & 1`
3. 获取x的第n位的幂值：`x & (1 << n)`
4. 将x的第n位置为1： `x | (1 << n)`
5. 将x的第n位置为0： `x & ~(1 << n)`
6. 将x的最高位到第n位清零： `x & ((1 << n) - 1)`

### 实战要点

* 判断奇偶：`x & 1 ==? 0`, 只用判断最低位是否为1，因为高位肯定都是2的幂，所以肯定可以被2整除，只用判断最低位
* 清零最低位的1：`x & (x - 1)`: `1100 & 1011 ==> 1000`
* 得到最低位的1：`x & -x`
* `x & ~x == 0`

### 位运算解决N皇后2
整体的思路是明确的，就是将`普通算法里的数组或者集合`替换成`n位的二进制整数` 来判断哪些 列、撇、捺 使用过，哪些可以使用, 从而减少额外空间利用，减少空间复杂度；
但还是有点不太明确的地方，就是在进行深层次递归的时候，传递新的na的参数时是`先或后位移`, 而不是`na | (p >> 1)`，这样不会将最低位的1给位移没了么?


## 布隆过滤器

* 一个`很长的二进制向量`和一系列`随机映射函数`
* 用于检测一个元素是否在集合中
* 优点：空间效率和查询时间都远远优于一般算法
* 缺点：有一定误识别率和删除困难


## 排序

### 排序算法

* 比较类排序：需要比较两个元素之间的关系，复杂度不能突破O(nlogn), 但可以比较非整形的元素；
* 非比较类排序：不通过比较两个元素之间的关系来排序，可以突破到线性时间，但一般限制需要是整形数据；

### 初级排序O(n^2)
* 选择排序: 每次找剩余元素最小值放在最前，依次类推;
* 插入排序：每次在待排序数组里的取出最前面的元素，然后和前面已经排序的部分，计算应该放在已排序部分的什么位置，插入
* 冒泡排序：两层嵌套循环，依次比较相邻的两个元素是否逆序，如果逆序，交换位置
`选择排序是每次把最小值放前面，而冒泡排序是一层便利后把最大值放在末尾，可以看作两者思想是相反的。`

### 高级排序 O(nlogn)
* 快速排序：每次选择一个标杆元素，把所有小于标杆的元素都放在左侧，其他放在右侧，并依次对左右两则的进行类似的处理;
* 归并排序(分治的思想)：将数组一分为二，然后分别对左右两边排序（递归），最后将结果合并成个有序数组（需要额外申请一个内存空间，用来合并两个有序数组）;
* 堆排序：将数组元素依次押入大（小）顶堆，然后依次弹出来；
