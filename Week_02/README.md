学习笔记

### 哈希表
* 解构：哈希表保存把key通过一个哈希函数，转换成一个下标，这个下标指向一个值。
* 哈希碰撞：当哈希表会出现两个或多个key通过哈希函数计算后的值是相同的，这个叫哈希碰撞；解决哈希碰撞的方法之一是可以拉链式解决冲突：相同下标这里指向的是一个链表，对应的是多个值；
* 时间复杂度：查找、插入、删除都是O(n)。最坏情况下哈希冲突退化成为一个链表，查找、插入、删除的复杂度会变成O(n)；
* hashmap: 保存的方式是键值对，键不能重复，但值可以；
* hashset：保存元素本身，元素不重复；
* 应用：由于查找、插入和删除的时间复杂度都是O(1), 常用在需要去重或者统计次数的题目，可以简化复杂度

### 树
* 单链表几点如如果有多个子节点，就可以转换成树。
* 图：树的结构中出现了环（有多个节点的子节点指向了同一个节点）
* 链表是特殊化的树；树是特殊化的图；
* 二叉树：每一个父节点如果有子节点，且子节点的个数为2；
* 二叉树的遍历：
  1. 前序遍历(preorder): root -> left -> right;
  2. 中序遍历(inorder): left -> root -> right;
  3. 后序遍历(postorder): left -> right -> root;
  4. 二叉树的遍历大多用递归，是因为树的结构没办法有效的进行循环，用递归比较简洁明了；


* BST(二叉搜索树)：
  1. 中序遍历的结果是一个递增的数组；
  2. 空树也是一个BST；
  3. 左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值；左右子树的所有子树也满足上述特点；
  4. 复杂度：查询、插入、删除的复杂度嗾使O(logn)；

### 堆Heap
* 可以迅速找到最大值或者最小值的数据结构；
* 二叉堆（是一个【完全二叉树】，除了最下面一层叶子结点不满，其他节点都是满的）：
  1. 大顶堆：每一个根节点的值都大于他的子节点的值；
  2. 小顶堆：每一个根节点的值都小于他的子节点的值；
* 二叉堆可以用一位数组来实现：
  1. 根节点是下标为0的元素；
  2. 索引为i的左子节点的下标为 2*i+1；
  3. 索引为i的右子节点的下标为 2*i+2；
  4. 索引为i的父节点的下标为 int((i-1)/2);
* 复杂度：
  1. 取出最大值或最小值：O(1)
  2. 插入：O(logN);
* 二叉堆插入的操作：
  1. 新元素添加到数组的末尾；
  2. 依次向上浮动交换位置；
* 二叉堆删除最值的操作：O(logn)
  1. 将堆尾元素替换到堆首；
  2. 依次向下浮动交换位置: 和当前位置的较大（小）子节点进行交换；
* 应用场景：
  1. 取最大（小）值；
  2. TopK的题目；
  3. 滑动窗口问题；
* Python的库：heapq
  1. heapq.heapify(list) -> 讲一个 list 原地转换成为一个小顶堆；
  2. heapq.heappush(list, item)
  3. heapq.nlargest(n, iterable, key=None) 返回前n个最大值，在n较小是效率较高，n较大时可以用sorted，然后返回
  4. heapq.nsmallest(n, iterable, key=None) 返回前n个最小值，在n较小是效率较高，n较大时可以用sorted，然后返回

### 图 Glaph
* 点（vertex):
  1. 入度和出度
  2. 点和点是否（直接）连通；
  3. 如果点链接的边如果无向，则入度=出度
* 边 （edge）
  1. 有向和无向
  2. 权重（边长）
* 图的遍历的时候需要加上visited属性，因为有环，要加以判断。